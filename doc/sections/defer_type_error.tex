\section{Deferred Type Errors}

Equality Proofs and Deferred Type Errors, ICFP'12 \citep{vytiniotis2012equality}.

\subsection{Motivation}

Based on $\FCpro$, the coercion type $[[ s1 ~ s2 ]]$ is now an ordinary type.
Therefore, we can have ordinary values of this type, and the value can be passed
to or returned from arbitrary terms. This proofs-as-values approach opens up an
entirely new possibility, that of deferring type errors to runtime.

\begin{Verbatim}[commandchars=\\\{\}]
foo = (True, 'a' && False)

foo = let (c : Char \mytilde Bool) = error 'Cound't ...'
      in (True, (cast 'a' c) && False)
\end{Verbatim}

Here we manually define an evidence $ c : [[ char ~ bool]]$ which actually emits
an error, which can be used to type check the program and defer the error to
runtime.

\subsection{Notes}

\begin{itemize}
  \item The original \textit{erasable} type constructor $[[~]]$ is renamed to
    $[[~#]]$, and the kind $[[ constraint ]]$ is renamed to $[[ constraint#]]$.
  \item There are two kinds of coercions
    \begin{itemize}
      \item $[[~#]]$, the type for primitive coercions $[[co]]$. Erasable.
      \item $[[~]]$, the type of evidence generated by the type inference
        engine. Cannot be erased.
        Defined as a GADT
\begin{Verbatim}[commandchars=\\\{\}]
data a \mytilde b where
  Eq# :: (a \mytilde# b) -> a \mytilde b

\mytilde : forall X. X -> X -> *
Eq# : forall X. forall (a : X). forall (b : X). (a \mytilde# b) -> (a \mytilde b)
\end{Verbatim}
    \end{itemize}
  \item Then we can define the function \verb|cast|. Each use of cast forces
    evaluation of the coercion, via the \verb|case| expression, which in the
    case of a deferred type error, triggers the runtime failure.
\begin{Verbatim}[commandchars=\\\{\}]
cast : forall (a b : *). a -> (a \mytilde b) -> b
cast = \myLambda(a b : *). \myslash(x:a). \myslash(eq:a \mytilde b).
  case eq of
    Eq# (c: a \mytilde# b) -> x |> c
\end{Verbatim}
  \item  The relation between $[[~#]]$ and $[[~]]$ is analogous to that between
    $[[int]]$ and $[[int#]]$. Refer to \citet{jones1991unboxed} for more details.
  \item  How it works: during constraint generation, we generate a type-equality
    constraint even for unifications that are \textit{unsolvable}. We emit a
    warning, and create a value binding for the constraint valuable, which binds
    it to a call to error, applied to the error message string.
  \item The optimization uses wrapper, and re-boxing, so that most equality
    evidences can be optimized away.
\end{itemize}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../doc"
%%% org-ref-default-bibliography: "../doc.bib"
%%% End: